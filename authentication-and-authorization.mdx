---
title: Understanding Authentication And Authorization in Mindbricks
---
## Scope

Mindbricks is an AI-powered, pattern-based backend microservice code generator.
This document aims to guide human or AI architects\* in designing applications on Mindbricks with authentication and authorization capabilities.
It is recommended to read this document alongside the Mindbricks Pattern documentation, especially for the referenced patterns.

```plaintext
*Architect refers to either AI agents or human users of Mindbricks, including product managers, business analysts, and software architects.
Throughout this document, the term "architect" will be used interchangeably for both without further distinction.
```

### Pattern Reference

In this document, specific feature configurations and options are illustrated using a JavaScript object path notation, such as:

```js
authentication.loginDefinition.userSettings.userNameType = "asFullname";
```

For human architects, this notation should be interpreted as a UI navigation path. For example:
Go to the **Authentication** module menu of the project, open the **Login Definition** chapter, expand the **User Settings** section accordion, and set the **User Name Type** option to "As Fullname".

For AI agents, this notation indicates setting the `userNameType` property of the `userSettings` JSON object, which is nested within the `loginDefinition` object under the `authentication` module.

## Mindbricks Authentication Module

While a Mindbricks project consists primarily of service modules, it also includes several core modules that must or can be defined to enable common functionalities.
One such core module is the **Authentication** module, which governs authentication and authorization behavior across all Mindbricks services, particularly the `auth` service â€” a service automatically generated by Mindbricks based on this moduleâ€™s configuration.

Human architects can access and configure this module by opening the **Authentication** menu in the project sidebar, loading each chapter, and setting the relevant options.
Most chapters of the **Authentication** module will be covered in this document; however, for a pattern-based understanding, you should also refer to the **Mindbricks Patterns** documentation, specifically the **ProjectAuthentication** pattern.

**AI agents** should populate the authentication moduleâ€™s settings according to the pattern definitions and the guidelines provided here.

Although the Authentication module primarily manages authentication and authorization behavior, certain settings might still need to be configured within individual service modules.

The **`ProjectAuthentication`** pattern structure

```json
{
  "ProjectAuthentication": {
    "authenticationEssentials": "AuthBasics",
    "loginDefinition": "LoginDefinition",
    "verificationServices": "VerificationServices",
    "accessControl": "AccessControl",
    "socialLogins": "SocialLoginSettings",
    "userProperties": ["DataProperty"],
    "tenantProperties": ["DataProperty"],
    "ssoAuthentication": "SSOAuth"
  }
}
```

## Mindbricks services and the `Auth` service

While most business logic and data management in Mindbricks are handled through services designed by architects, some core functionalities are bundled into automatically generated services based on project settings â€” the auth service is one of them.

Once you activate the auth service, Mindbricks ensures that the application design and the generated codebase include a microservice named `auth`.

The `auth` service provides and manages the following functionalities:

1. User and user data management

2. User group management

3. Login and logout operations

4. Verification services

5. Role management (RBAC)

6. Permission management (PBAC)

7. Multi-tenancy management

### How can you extend Auth functionality

1. **Through Configuration Settings:**
   You can customize or extend authentication behavior by modifying settings within the Authentication module.For example, you can add extra user or tenant properties, define custom roles, and configure permissions directly via settings.

2. **Through Additional Services:**
   Although it's ideal to stick to the auth service for authentication-related processes, you can design additional services to extend behavior.
   For example, if your user data model is distributed across multiple complex objects (tables, in conventional terms), you can create an extra service (e.g., userProfile) and link it to the users in the auth service using the userId.

## User and User Data Management

When the auth service is created, a default `user` data object is automatically included in its service definition.
Thus, once the `auth` service is active, you can always reference the `user` data object from anywhere within other services.

The user object comes with several **system-defined properties** â€” some mandatory, some optional.
Additionally, architects can **add custom properties**, similar to how they design data objects in other Mindbricks services.
.

### `user` Data Object Properties (System owned)

Mindbricks automatically generates the following system properties for the `user` object:

1. **`id`** :
   A unique identifier (`UUID`) for each user.
   Like all other Mindbricks data objects, the id field is automatically included.

- Appears in objects like session as `userId`.

- Other data objects will reference the user with `userId`.

1. **`email`** :
   Represents the user's email address.

- Serves as both a unique identifier and the primary username for login.

- Also used for communication, notifications, and verification flows.

1. **`password`** :
   Stores the user's password securely.

- Passwords are hashed and salted using a one-way algorithm â€” they are never stored in plain text.

1. **`emailVerified`** :
   Indicates whether the user's email address has been verified.

Even if email verification is optional in your application, this field exists.
To require email verification before login, set:

```js
authentication.loginDefinition.userSettings.emailVerificationRequiredForLogin = true;
```

If email verification is required, the frontend will receive an `emailVerificationNeeded` message and must trigger the email verification flow. (See **Mindbricks Auth Service Api Guide** for full details.)

1. **Naming Properties** : User names can be stored either as a full name or as a name-surname pair, configurable via:

```js
authentication.loginDefinition.userSettings.userNameType = "asFullname"; // or "asNamePair"
```

- **`name`** : First (and middle, if any) name when using a name pair.

- **`surname`** : Family name when using a name pair.

- **`fullname`** : Full name when using the full name mode.

1. **`avatar`** :
   A URL pointing to the user's avatar image.

- The auth service only stores the URL â€” it does not manage uploads.

- Image uploading should be handled by the API consumer (e.g., using Mindbricks Bucket Service).

To enable auto-generation of avatars (e.g., via Gravatar):

```js
authentication.loginDefinition.userSettings.userAutoAvatarServiceUrl =
  "https://gravatar.com/avatar/{{uniqueHash}}?s=200&d=identicon";
```

- `{{uniqueHash}}` or `{{uniqueInt}}` are placeholders for user-specific seeds when needed in avatar service.

1. **`roleId`** : \[Optional]
   Stores the user's assigned role(s), activated when **RBAC** (Role-Based Access Control) is enabled:

```js
authentication.accessControl.roleSettings.rbacIsActive = true; // or false
```

Configurable as:

- **String** (recommended) or **Integer**

- Single or multiple roles (array)
  Example settings:

```js
authentication.accessControl.roleSettings.roleIdDataType = "isString"; // or "isInteger"
authentication.accessControl.roleSettings.usersHaveMultipleRoles = false; // or true
```

See [Role Management](#roleManagement) for details

1. **`mobile`** : \[Optional]
   Represents the userâ€™s mobile phone number, activated via:

```js
authentication.loginDefinition.userSettings.userMobileIsActive = true;
authentication.loginDefinition.userSettings.mobileVerificationRequiredForLogin = true; // or false
```

1. **`mobileVerified`** : \[Optional]
   Indicates whether the user's mobile number has been verified.
   (Active only if `userMobileIsActive` is set to true.)
   Activated via :

```js
authentication.loginDefinition.userSettings.mobileVerificationRequiredForLogin = true; // or false
```

### The tenant id property in `user` Object (for Multi-Tenant Apps)

In multi-tenant applications, users belong to specific tenants, and **email uniqueness is tenant-scoped**.

The tenant ID field's name depends on your tenant naming settings â€” for instance:

- `clientId` if tenant name is "client"

- `storeId` if tenant name is "store"
  Enable multi-tenant mode via:

```js
authentication.loginDefinition.tenantSettings.useMultiTenantFeature = true; // or false
```

For a complete understanding of multi-tenancy, refer to [Multi-Tenancy Management](#tenantManagement)

### Custom `user` Data Properties

You can freely add custom properties to the user object, provided their names do not conflict with system-defined fields.

To add custom properties:

```js
authentication.userProperties = [customProperty1, customProperty2];
```

Each custom property must follow the `DataProperty` pattern.

Human architects can add these properties in the **User Properties** section under the **Authentication** module UI, while **AI** agents should populate them programmatically.

Example of a custom property (sex):

```json
{
  "basicSettings": {
    "name": "sex",
    "type": "Enum",
    "isArray": false,
    "definition": "The sex value of the user.",
    "isRequired": true,
    "allowUpdate": true,
    "requiredInUpdate": false,
    "allowAutoUpdate": true,
    "defaultValues": {
      "default": 0,
      "defaultInUpdate": null
    }
  },
  "indexSettings": {
    "indexedInElastic": true,
    "indexedInDb": false
  },
  "enumSettings": {
    "hasEnumOptions": true,
    "enumOptions": ["male", "female"]
  }
}
```

### Super Admin Account

When the application is deployed, Mindbricks automatically creates a **Super Admin** account in the `users` table of the `auth` service.
This account holds absolute authority, granting full access and control across the system.

The Super Admin role is internally recognized as `superAdmin`.
You must define a **Super Admin email address** (used as the username) and a password during configuration.
The email address does **not** have to be real; it is only used for login purposes â€” no communications will be sent to it.

Configure the Super Admin credentials using the following settings:

```js
authentication.loginDefinition.userSettings.superAdminEmail = "super.admin@myproject.com";
authentication.loginDefinition.userSettings.superAdminPassword = "yourPassword";
```

Once set, Mindbricks will create a row in the `users` table for the **Super Admin**, populating standard system fields automatically.

#### Setting Custom Data for Super Admin

If your project defines additional **custom user properties**, Mindbricks allows you to prepopulate these fields for the Super Admin account as well.

Use the `superAdminData` setting to define an array of `DataMapItem` (property-value pairs):

```js
authentication.loginDefinition.userSettings.superAdminData = [yourAdminDataMapItems];
```

Example of a superAdminData JSON object:

```js
{
  items: [
    {
      "name": "age",
      "value": 25
    },
    {
      "name": "instagramName",
      "value": "myProjectOffical"
    }
  ]
}
```

**Note:**
If a value for a required custom property is missing, Mindbricks will:

- Use the fieldâ€™s default value (if defined), or

- Leave it `null` (only if nulls are allowed).

### User registration

User registration in the `auth` service can be configured to be public or restricted.

- **Public registration** allows anyone to create an account without requiring prior authorization.

- **Restricted registration** means only administrators (with `admin` roles) can create user accounts.

You can control this behavior with the following setting:

```js
authentication.loginDefinition.userSettings.userRegisterIsPublic = true; // or false
```

**Important:**
When `userRegisterIsPublic` is set to `true`, the POST /users API endpoint can be accessed **without an access token.**
While public registration is allowed, Mindbricks automatically applies **rate limiting** and **anti-bot** protections to prevent abuse.

If `userRegisterIsPublic` is set to false, the `POST /users` API requires an authenticated `admin` user session.

## User Group Management

The Mindbricks `auth` service supports **user grouping**, allowing architects to organize users into logical groups.
This is particularly useful for **permission management**, but it can also support other group-based business logic across services.

- A user can belong to **zero, one, or multiple groups**.

- Only users with **admin roles** can create user groups and assign users to them.

To enable user grouping, use the following setting:

```js
authentication.loginDefinition.userSettings.userGroupsActive = true; // or false
```

When `userGroupsActive` is set to true, the `auth` service automatically includes two additional data objects:

- `userGroup`

- `userGroupMember`

### `userGroup` Data Object Properties (System owned)

The `userGroup` data object will store the names and avatars of the created user group.
The system creates these following user group data properties with these names.

This object stores metadata about each user group.
The following fields are created automatically:

1. **id** :
   A UUID representing the unique identity of the user group.

2. **groupName** :
   The name of the group, which will be shown in the applicationâ€™s UX.

3. **avatar** :
   A public URL pointing to the group's avatar image.

*Like user avatars, the system&#x20;****does not manage image uploads****&#x20;â€” this must be handled externally (e.g., via the Bucket service).*
You can also configure auto-generated avatars using services like Gravatar:

```js
authentication.loginDefinition.userSettings.userGroupAutoAvatarServiceUrl =
  "https://gravatar.com/avatar/{{uniqueHash}}?s=200&d=identicon";
```

Use  or  to ensure unique avatars per group.

### `userGroupMember` Data Object Properties (System owned)

This object manages the relationships between users and groups â€” each record represents one membership.

Automatically created properties include:

1. **id** :
   A UUID representing this specific user-group membership.
   Used also when removing a user from a group.

2. **groupId** :
   The id of the group.

3. **userId** :
   The id of the user.

4. **ownerId** :
   The id of the admin user who created this membership record.
   Automatically populated from the current session.

### Tenant-Level Grouping

In multi-tenant applications, you can choose whether user groups are tenant-scoped or global:

- **Tenant-level groups:** Created and visible only within the tenant that owns them. Only tenant admins can manage them.

- **SaaS-level (global) groups:** Visible to all tenants, created only by SaaS-level (super admin) users. Tenant admins can still assign users to global groups but cannot create or delete them.

To enable tenant-level grouping:

```js
authentication.loginDefinition.userSettings.userGroupsInTenantLevel = true; // or false
```

When this is enabled, a `tenantId` property will also be added to the `userGroup` and `userGroupMember` data objects with a specific name generated from tenant name like `clientId`.

For more details, see
[Multi Tenancy Management](#tenantManagement).

## Login Management

The Mindbricks auth service supports multiple login methods, including:

- Native username/password login

- Social logins (e.g., Google, Apple)

- SSO (Single Sign-On)

Each login method ultimately integrates with the same authentication flow, issuing a **JWT token** upon success. This token is used for subsequent request authentication.

### Login Via Username and Password

The most common login method is via **email (username)** and **password**.
This process depends on **JWT authentication**, which is enabled by default:

```js
authentication.authenticationEssentials.JWTAuthentication.useJWTForAuthentication = true; // or false
```

Mindbricks creates a **JWT access token** after successful login, which is then used to authenticate subsequent requests â€” either via cookie or Authorization header.

To initiate a login, the API consumer should call: `POST /login`

If login is successful:

- A session is returned in the response.

- A JWT token is issued.

- A browser-accessible cookie is set (for web-based clients).
  The token can also be sent in future requests via the `Authorization: Bearer` header.

### Email and Mobile Verification During Login

Mindbricks allows email and/or mobile number verification as prerequisites for login.
This ensures users have verified contact information before gaining access.

The user model includes two flags:

- `emailVerified`

- `mobileVerified`

You can require verification before login with:

```js
authentication.loginDefinition.userSettings.emailVerificationRequiredForLogin = true;
authentication.loginDefinition.userSettings.mobileVerificationRequiredForLogin = true;
```

If a user tries to log in without verifying their email or mobile (when required), the system responds with:

```js
{
  result: "ERR",
  status: 403,
  message: "errMsg_EmailNotVerified",
  errCode: "EmailVerificationNeeded"
}

// OR

{
  result: "ERR",
  status: 403,
  message: "errMsg_MobileNotVerified",
  errCode: "MobileVerificationNeeded"
}
```

*Tip: It's good UX to handle verifications during or immediately after registration.
Mindbricks also includes verification status in registration responses:*

```js
{
  emailVerificationNeeded: true
}

// OR

{
  mobileVerificationNeeded: true
}
```

### Two-Factor Authentication (2FA)

Mindbricks supports 2FA using email or mobile. Unlike pre-verification, 2FA occurs after password login (or social/sso logins).

If 2FA is enabled and triggered, the session is created, but marked as needing a second step:

```js
{
  sessionNeedsEmail2FA: true
}

// OR

{
  sessionNeedsMobile2FA: true
}
```

Enable 2FA with:

```js
authentication.loginDefinition.userSettings.email2FARequiredForLogin = true; // or false
```

```js
authentication.loginDefinition.userSettings.mobile2FARequiredForLogin = true; // or false
```

If the second factor is not completed, all subsequent requests will fail with a 403 until resolved:

```js
{
  result: "ERR",
  status: 403,
  message: "errMsg_{RouteName}RequiresEmail2FA",
  errCode: "EmailTwoFactorNeeded"
}

// OR

{
  result: "ERR",
  status: 403,
  message: "errMsg_{RouteName}RequiresMobile2FA",
  errCode: "MobileTwoFactorNeeded"
}
```

### Social Logins

Mindbricks auth service supports social login via Google and Apple, with more providers planned for future versions.

Social login allows users to sign in using their existing social accounts.
Behind the scenes, Mindbricks uses OAuth 2.0 to authenticate the userâ€™s email through the social platform.

Once verified:

- If the user already exists, they are logged in.

- If not, Mindbricks auto-creates the user account using the information returned by the provider.

#### Enabling Social Login

To enable Google login, configure:

```js
authentication.socialLogins.google.clientId = yourGoggleClientIdHere;
authentication.socialLogins.google.clientSecret = yourGoggleClientSecretHere;
```

To enable Apple login, only a client ID is needed:

```js
authentication.socialLogins.apple.clientId = yourAppleClientIdHere;
```

#### Controlling Auto-Registration via Social Login

By default, if a user logs in through a social provider and doesnâ€™t already have an account, Mindbricks creates it automatically.

You can disable auto-registration if needed:

```js
authentication.socialLogins.google.useForRegister = false; // or true
authentication.socialLogins.apple.useForRegister = false; // or true
```

This lets you use social login only for **authenticated access**, not for onboarding.

**Security Note**
Although OAuth is used to verify email ownership, **Mindbricks treats the login as a native one** once the email is verified.

This means:

- A session is created

- A JWT token is issued

- The same permission and role systems apply as in other login methods
  The full login flow for API consumers is detailed in the **Mindbricks Auth Service Api Guide**.

### SSO Login (Single Sign-On)

Mindbricks `auth` service supports **SSO-based authentication**, enabling users to log in through an **external identity provider** (such as an organization's SSO server).
This is ideal for enterprise applications where user identity is centrally managed.

Once the user is authenticated by the SSO provider, Mindbricks generates its own **JWT session token**, just like it would in a native login.

Enabling SSO Authentication
To activate SSO in your project, use the following settings:

```js
authentication.authenticationEssentials.ssoAuthentication.useSSOForAuthentication = true; // or false
authentication.authenticationEssentials.ssoAuthentication.ssoName = "yourSSOName"; // A short identifier
```

#### Profile Mapping

Mindbricks does not assume any fixed field names in the user profile returned by your SSO provider.
Instead, it allows you to **explicitly define** which fields should be used for email, username, and the external SSO user ID.

Configure the mappings as follows:

```js
authentication.authenticationEssentials.ssoAuthentication.emailPropertyInProfile = "email";
authentication.authenticationEssentials.ssoAuthentication.userNamePropertyInProfile = "name";
authentication.authenticationEssentials.ssoAuthentication.ssoUserIdPropertyInProfile = "sub";
```

These settings tell Mindbricks how to extract relevant data from the SSO profile:

- **emailPropertyInProfile:** Specifies which field in the SSO profile represents the user's email.
  ðŸ‘‰ This is required â€” authentication and user matching are based on this field.

- **userNamePropertyInProfile:** Specifies which field should be used as the userâ€™s name (optional, mainly used during registration).

- **ssoUserIdPropertyInProfile:** Specifies a unique external ID for the user (optional).
  ðŸ‘‰ If provided, it will be included in the session object as `SSOUserId`.

For example, if your SSO provider returns a profile like:

```json
{
  "user_email": "jane@example.com",
  "displayName": "Jane Doe",
  "user_id": "abc-123"
}
```

Then your configuration would be:

```js
authentication.authenticationEssentials.ssoAuthentication.emailPropertyInProfile = "user_email";
authentication.authenticationEssentials.ssoAuthentication.userNamePropertyInProfile = "displayName";
authentication.authenticationEssentials.ssoAuthentication.ssoUserIdPropertyInProfile = "user_id";
```

This flexibility ensures Mindbricks can work seamlessly with various SSO systems, regardless of their field naming conventions.

#### Token Behavior and Expiry

Since SSO tokens are tied to a remote identity provider, they typically have a shorter lifespan than native tokens.

You can customize the default duration (in minutes):

```js
authentication.authenticationEssentials.ssoAuthentication.tokenPeriodInMinutes = 15;
```

#### Configuring SSO Server Integration

Mindbricks needs to know how to interact with the external SSO provider.
Configure the required URLs and credentials:

```js
authentication.authenticationEssentials.ssoAuthentication.ssoServerSettings = {
  tokenHost: "auth.mysso.com",
  authPath: "/auth",
  tokenPath: "/token",
  userInfoPath: "/profile",
  logoutPath: "/logout",
  clientId: "yourClientId",
  clientSecret: "yourClientSecret",
  redirectUrl: "https://app.myApplication.com/home"
};
```

- The `redirectUrl` is where the SSO server will send the user after authentication.

- Make sure your frontend is prepared to handle the redirect and initiate session establishment.

### Remote Service Login

*Will be presented in MVP*

### Access token management

After a successful login (whether native, social, or SSO), Mindbricks `auth` service issues a JWT (JSON Web Token).
This token serves as the main credential for authenticating API requests throughout the user's session.

#### Token expiration

JWT tokens have a **limited lifetime** to ensure security.
When a token expires, Mindbricks services automatically reject it with an HTTP 401 Unauthorized error, prompting the client to reauthenticate.

You can configure the tokenâ€™s lifetime (**in days**) with:

```js
authentication.authenticationEssentials.JWTAuthentication.tokenPeriodInDays = 30;
```

- After the configured period, the token becomes invalid.

- Clients must then perform a new login to obtain a fresh token.

#### Key management for token verification

Each token is **digitally signed** by the auth service using its **private key**.
The corresponding **public key** is made available via the auth serviceâ€™s public API (`GET /publickey`), allowing other services to verify the tokenâ€™s signature securely.

Mindbricks implements **key rotation** to enhance security:

- The private key can be refreshed automatically at intervals you define.

- When a key is rotated, a **Key ID** (`kid`) is embedded in each JWT to indicate which public key should be used for verification.

You can configure the key refresh period (in **days**) with:

```js
authentication.authenticationEssentials.JWTAuthentication.keyRefreshPeriodInDays = 150;
```

- Set it to 0 to disable automatic key rotation.

- Regular key rotation is recommended for high-security environments but not mandatory for all projects.

#### Access Token Usage in API Consumption

When a client application makes API calls, it must present the JWT token for authentication.
Mindbricks services look for the token in this order:

1. **Query Parameter (****`access_token`****)**

2. **Authorization Header (****`Bearer scheme`****)**

3. **Custom Header** (same as cookie name)

4. **Cookie**

**Cookie And Header Naming Convention:**

- In single-tenant projects:
  `{projectName}-access-token`

- In multi-tenant projects:
  `{projectName}-access-token-{tenantCodename}`

Both the cookie and the custom header use the same naming convention.

In a single-tenant context:

- Cookie: `myApp-access-token`

- Header: `myApp-access-token`

In a multi-tenant context with tenantCodename `store123`:

- Cookie: `myApp-access-token-store123`

- Header: `myApp-access-token-store123`

This approach ensures clarity, avoids exposing internal UUIDs, and makes tenant-based request handling much easier in frontend apps, proxies, or multi-tenant client logic.

## Verification Services

The Mindbricks auth service provides several built-in verification flows, which API consumers can use during login, registration, password reset, or other user-related operations.

These include:

- Password Reset (by Email or Mobile)

- Email Verification

- Mobile Verification

- Two-Factor Authentication (2FA) via Email or Mobile

* Action Approval by Email

* Action Approval by Mobile

Each verification flow follows a **consistent lifecycle pattern**:

1. The client application starts the flow by calling a **start API**.

2. The server generates a one-time **code** (or **link**).

3. The code or link is sent to the user via **email** or SMS.

4. The client application submits the code to the server â€” either:

- by letting the user enter the code manually, or

- by capturing the code automatically when the user clicks a verification link.

1. The server completes the verification, and any associated action is performed.

### General Configuration

All verification services are configured under:
`authentication.verificationServices`

Each verification type has its own sub-configuration, for example:

```js
authentication.verificationServices.passwordResetByEmail;
authentication.verificationServices.passwordResetByMobile;

authentication.verificationServices.email2Factor;
authentication.verificationServices.mobile2Factor;

authentication.verificationServices.emailVerification;
authentication.verificationServices.mobileVerification;
```

### Shared Settings Across Verifications

All verifications support the following configuration options:

1. `isActive`
   Enables or disables the verification feature.

```js
authentication.verificationServices.passwordResetByEmail.passwordResetByEmailIsActive = true;

authentication.verificationServices.mobile2Factor.mobile2FactorIsActive = true;
```

All verification types follow this pattern.

1. `resendTimeWindow` (in seconds)
   Defines how often a user can request a new verification code.

```js
authentication.verificationServices.passwordResetByEmail.resendTimeWindow = 3600;
authentication.verificationServices.mobileVerification.resendTimeWindow = 60;
```

If a client requests a code within this window, the server responds with:

```js
{
  errCode: "errEmailCodeCanBeSentOnceInTheTimeWindow"
}

// or

{
  errCode: "errMobileCodeCanBeSentOnceInTheTimeWindow"
}
```

1. expireTimeWindow (in seconds)
   Defines how long a code remains valid after it's issued.

```js
authentication.verificationServices.passwordResetByEmail.expireTimeWindow = 86400;
authentication.verificationServices.mobile2Factor.expireTimeWindow = 60;

// other verifications use the same pattern for expireTimeWindow setting.
```

If the verification attempt comes after the expiration, the server returns:

```js
{
  errCode: "errEmailCodeHasExpired"
}

// or

{
  errCode: "errMobileCodeHasExpired"
}
```

1. `verificationType`: `"byCode"` or `"byLink"`

Specifies how the verification code is delivered and used:

`"byCode"`: A 6-digit numeric code to be entered by the user
`"byLink"`: A direct link that the user clicks to verify

```js
authentication.verificationServices.passwordResetByEmail.verificationType = "byLink"; // or "byCode"
authentication.verificationServices.passwordResetByMobile.expireTimeWindow = "byCode"; // or "byLink"

// other verifications use the same pattern for verificationType setting.
```

ðŸ’¡ Common convention:

- Use `"byLink"` for email-based verifications

- Use `"byCode"` for mobile (SMS) verifications

### Verification URLs (for byLink)

When using the `"byLink"` method, the server generates a link that points to a specific page on your frontend.
These links are constructed using the projectâ€™s **root web address** plus a predefined path, such as:

```text
https://app.myApp.com/passwordResetByEmail/{hashCode}
https://app.myApp.com/mobileVerification/{hashCode}
```

The frontend should implement handling for each of the following paths, based on your configuration:

- `/passwordResetByEmail/{hash}`

- `/passwordResetByMobile/{hash}`

- `/emailVerification/{hash}`

- `/mobileVerification/{hash}`

- `/email2Factor/{hash}`

- `/mobile2Factor/{hash}`

## Role Management (RBAC)

Mindbricks supports **Role-Based Access Control (RBAC**)\*\* as a flexible and declarative way to manage user permissions across your application.
RBAC can be enabled and customized through the `roleSettings` section of the `AccessControl` module.

The related configuration is defined by the `RBACSettings` pattern.

### Enabling RBAC

To enable role-based access control in your project, set the following configuration:

```js
authentication.accessControl.roleSettings.rbacIsActive = true;
```

When active, this allows the `auth` service and other modules to enforce access control based on user roles.

### Defining Roles

Roles are defined using the `rolesObject` array, which is a list of RoleItem objects.

Each role consists of:

- `name`: A human-readable label (used in UX or logs)

- `value`: The actual value stored in the `user.roleId` field and in the session

Example:

```js
authentication.accessControl.roleSettings.rolesObject = [
  { name: "admin", value: "admin" },
  { name: "user", value: "user" },
  { name: "manager", value: "manager" }
];
```

### Role ID Data Type

You can configure the data type of the roleId field in the user object:

```js
authentication.accessControl.roleSettings.roleIdDataType = "isString"; // or "isInteger"
```

- Use `isString` for semantic roles like `"admin"`, `"editor"`, etc.

- Use `isInteger` if roles are numeric and follow an ordinal or priority structure.

### Multiple Roles per User

By default, each user has a **single role**

You can allow users to have **multiple roles** by enabling:

```js
authentication.accessControl.roleSettings.usersHaveMultipleRoles = true;
```

When enabled, the `roleId` property in the user object becomes an **array**.
Supported in both PostgreSQL and MongoDB.

### Custom Role Lookups

In addition to explicit role assignments, Mindbricks allows **dynamic roles** to be defined using custom lookups.
These logical roles are derived based on conditions and are defined using **MScript** expressions.

```js
authentication.accessControl.roleSettings.customRoleLookups = {
  items: [
    {
      name: "isProjectAdmin",
      value: "user.id == this.project.ownerId;"
    }
  ]
};
```

- These logical roles are **evaluated at runtime**.

- They can be used for advanced access control scenarios where role membership depends on dynamic data or relationships.

### Accessing Role Data in the Session

Once RBAC is enabled:

- The userâ€™s role(s) are available in the `session.roleId` property.

- If multiple roles are allowed, `roleId` will be an array.

These roles can be used in access rules, permissions, and client-side logic.

## Permission Management (PBAC)

In addition to role-based access, Mindbricks offers **Permission-Based Access Control (PBAC)** â€” a highly flexible, fine-grained system that allows you to assign and evaluate permissions at various levels of the system.

PBAC is configured under the `permissionBasics`, `permissionTypes`, `objectBasedSettings`, and `attributeBasedSettings` sections of the AccessControl module.

### Enabling PBAC

To activate PBAC for your project:

```js
authentication.accessControl.permissionBasics.pbacIsActive = true;
```

This enables permission definitions, groupings, and permission enforcement across modules and services.

### Defining Permissions and Groups

Permissions are defined in named groups to make them easier to manage and reference.
Each group is a PermissionGroup object containing a name and a list of permission strings.

```js
authentication.accessControl.permissionBasics.permissionGroups = [
  {
    groupName: "projectManagement",
    permissions: ["createProject", "editProject", "deleteProject"]
  },
  {
    groupName: "userManagement",
    permissions: ["inviteUser", "removeUser"]
  }
];
```

Each permission name must be **unique** across the project.
Permissions can be referenced as `groupName.permission` or directly as `permission`.

### Types of Permission Assignments

You can assign permissions in multiple ways, based on whatâ€™s active in the system.
These are configured under `permissionTypes`:

```js
authentication.accessControl.permissionTypes = {
  roleBasedPermissionsIsActive: true,
  userBasedPermissionsIsActive: true,
  userGroupBasedPermissionsIsActive: true,
  objectBasedPermissionsIsActive: true,
  specialTenantPermissionsIsActive: true
};
```

1. Role-Based Permissions
   Permissions assigned to roles.
   Available when `roleBasedPermissionsIsActive` is `true`.

2. User-Based Permissions
   Permissions assigned to specific users.
   Available when `userBasedPermissionsIsActive` is `true`.

3. User Group-Based Permissions
   Permissions assigned to user groups.
   Available when `userGroupBasedPermissionsIsActive` is `true`.

4. Object-Based Permissions (OBAC)
   Permissions scoped to specific data objects.

Enable it with:

```js
authentication.accessControl.objectBasedSettings.objectBasedPermissionsIsActive = true;
authentication.accessControl.objectBasedSettings.dataObjects = ["project", "invoice"];
```

This restricts permissions based on object ownership or relation â€” e.g., only users assigned to a project can edit it.

### Special Tenant Permissions

In Mindbricks multi-tenant applications, all permissions are naturally tenant-aware â€” users, roles, and groups operate within tenant boundaries by default.

However, when `specialTenantPermissionsIsActive` is set to `true`, Mindbricks enables **SaaS-level administrators** to assign **extra permissions or features** to specific tenants.

```js
authentication.accessControl.permissionTypes.specialTenantPermissionsIsActive = true;
```

These permissions are **not** tied to **users, roles, or user groups**, but rather to the **tenant entity** itself.

Use this mechanism to enable:

- Premium features for certain tenants

- Beta access for selected customers

- Functionality thatâ€™s restricted to a subset of your clients

Example use cases:

- Allowing tenant `clientX` to access a beta reporting dashboard.

- Granting `storeABC` additional API rate limits via permissions.

- Enabling certain permissions for tenants based on their subscription tier.

This feature acts similarly to `feature flags per tenant`, using a permission model rather than static boolean settings.

### Attribute-Based Access Control (ABAC)

Mindbricks also supports **ABAC â€” Attribute-Based Access Control** â€” which allows permission evaluation based on data-level filters and conditions.

Enable it with:

```js
authentication.accessControl.attributeBasedSettings.attributeBasedPermissionsIsActive = true;
```

Then define ABAC rules using `abacDefinitions`:

```js
authentication.accessControl.attributeBasedSettings.abacDefinitions = [
  {
    name: "projectEditors",
    dataObject: "project",
    whereClause: "{ projectType:'external' }",
    permissions: ["projectManagement.editProject"]
  }
];
```

`dataObject`: The name of the data object being protected.

`whereClause`: A JavaScript object snippet (stored as a string) describing the attribute rule.

`permissions`: The permissions granted when the rule evaluates to `true`.

ABAC definitions `override` previous permissions when matched â€” they are considered the most powerful rule type.

### PBAC Permission Types Summary

The following table summarizes the different types of permission control mechanisms available in Mindbricks' Permission-Based Access Control (PBAC) architecture.
Each mechanism can be individually activated based on the projectâ€™s authorization needs.

| Permission Type            | Description                                                     | Activation Setting Key            |
| -------------------------- | --------------------------------------------------------------- | --------------------------------- |
| Role-Based                 | Permissions granted based on roles                              | roleBasedPermissionsIsActive      |
| User-Based                 | Permissions granted directly to users                           | userBasedPermissionsIsActive      |
| User Group-Based           | Permissions granted to groups of users                          | userGroupBasedPermissionsIsActive |
| Special Tenant Permissions | Extra permissions granted to specific tenants (feature toggles) | specialTenantPermissionsIsActive  |
| Object-Based (OBAC)        | Permissions tied to specific object ownership or references     | objectBasedPermissionsIsActive    |
| Attribute-Based (ABAC)     | Permissions evaluated based on object/user attributes           | attributeBasedPermissionsIsActive |

### PBAC Permission Data Object: `givenPermissions`

When **Permission-Based Access Control (PBAC)** is enabled in a Mindbricks project, a dedicated permission data object is automatically created with the name `givenPermissions`.

This object stores permission assignments across roles, users, user groups, and specific data objects when needed.

Below are the system-owned properties of the PBAC permission object:

- **id**
  The unique identifier of the permission record.
  Mindbricks automatically generates an `id` field (UUID) for every data object, including permission entries.

- **permissionName**
  A string representing the named permission being assigned.
  It can be referenced either as `groupName.permissionName`, `permissionName`, or using wildcards like `groupName.*`.
  This field is required and indexed in both the database and ElasticSearch for fast access.

- **roleId**
  A string representing the role to which the permission is assigned.
  This field is optional. If filled, it links the permission to a role defined in the project's RBAC settings.

- **subjectUserId**
  A string representing the user ID to whom the permission is granted directly.
  This field is optional and is used for assigning permissions specifically at the user level, bypassing roles and groups when needed.

- **subjectUserGroupId**
  A string representing the user group ID to which the permission is assigned.
  This field is optional and supports assigning permissions at the user group level for easier bulk permission management.

- **objectId**
  A string representing the ID of a specific object instance (record) for which the permission applies.
  This is used in Object-Based Access Control (OBAC) to allow or restrict permissions for individual data entries.
  This field is optional.

- **canDo**
  A boolean field indicating whether the permission is granted (`true`) or explicitly denied (`false`).
  This field is required and defaults to `true`.
  Explicit negative permissions (`false`) can override broader positive permissions if needed, depending on the system's permission evaluation rules.

#### **Tenant-scoped ID (like clientId, storeId, etc.)**

In multi-tenant applications, the permission records also include a tenant-scoped ID.
The name of this field changes based on the projectâ€™s `tenantName` setting.
For example:

- If the tenant name is set to `"client"`, the field will be `clientId`.

- If it is `"store"`, the field will be `storeId`.

This field ensures that permissions are properly isolated between different tenants.
It is automatically added by Mindbricks when multi-tenancy is active.

## Multi Tenancy Management

Mindbricks supports both **single-tenant** and **multi-tenant** architectures.
Multi-tenancy enables multiple organizations, clients, or user groups to access your application in isolation from one another â€” each with its own private data and access scope.

All tenant-specific settings are configured under:

```js
authentication.loginDefinition.tenantSettings
```

This structure is based on the `LoginDefTenantSettings` pattern.

### Enabling Multi-Tenant Mode

To activate multi-tenant architecture:

```js
authentication.loginDefinition.tenantSettings.useMultiTenantFeature = true;
```

- By default, all projects are **single-tenant**, and tenant settings should not be defined unless this option is set to `true`.

- When enabled, Mindbricks treats all user, resource, and access structures as **tenant-scoped**.

- It will automatically add the appropriate **tenant ID** property to relevant data objects and restrict access accordingly.

### Defining the Tenant Concept

Each project must define a `tenant concept name`, which will be used:

- As the name of the **tenant data object**

- To prefix **related data structures**, such as `clientUser`, `storeUser`, or `workspaceUser`
  Set the tenant name with:

```js
authentication.loginDefinition.tenantSettings.tenantName = "client"; // or "store", "workspace", etc.
```

This value will also influence naming conventions throughout generated code and data models.

### Tenant Data Object

When multi-tenancy is enabled in a Mindbricks project, a dedicated **tenant data object** is created automatically.
This object represents the organizational unit of the application â€” such as a `store`, `client`, `organizer`, or any name defined through the `tenantName` setting.

The structure and behavior of this tenant data object are standardized, and it includes the following system-defined fields:

1. **name**
   A required string that represents a short, single-word name for the tenant.
   This field is user-defined during tenant creation and used for basic identification. It is also filterable in queries.

2. **codename**
   A required string used as a unique, machine-friendly identifier for the tenant.
   It is generated automatically based on the `name` field and must be unique across all tenants.
   This codename is used in places like cookie/header naming (`projectName-access-token-<tenantCodename>`), tenant-specific routing, and UI identification.

3. **fullname**
   A required string representing the full descriptive name of the tenant.
   This field can be used for display in UIs and reports.

4. **avatar**
   An optional string field representing a public URL to an avatar image for the tenant.
   If not provided, Mindbricks can auto-generate a default avatar (e.g., using Gravatar).
   This image is not uploaded by the auth service â€” it must be provided as a valid public URL.

5. **ownerId**
   An ID field referencing the user who created the tenant â€” typically considered the **tenant owner**.
   This is a required field and is automatically linked to the session user during tenant creation.
   It has a relation to the main `user` object of the project and can be used for filtering or access logic.

**custom fields**
You can define additional custom fields for the tenant object using the `tenantProperties` configuration:

```js
authentication.tenantProperties = [customTenantProperty1, customTenantProperty2];
```

Each item in the array must follow the `DataProperty` pattern, just like custom fields in user or other data objects.
These properties will be fully integrated into the tenant model and exposed for use during tenant creation, updates, filtering, or querying.

This tenant object is the foundational building block for multi-tenancy in Mindbricks.
All user accounts, services, and permissions can be scoped per tenant using the ID of this data object (e.g., `clientId`, `storeId`, etc.).

#### Example Custom Tenant Property

Below is a sample custom property configuration you can add to the `tenantProperties` array:

```json
{
  "basicSettings": {
    "name": "subscriptionLevel",
    "type": "Enum",
    "isArray": false,
    "definition": "The subscription level of the tenant (e.g., Free, Pro, Enterprise).",
    "isRequired": true,
    "allowUpdate": true,
    "requiredInUpdate": false,
    "allowAutoUpdate": false,
    "autoIncrement": false,
    "hashed": false,
    "defaultValues": {
      "default": "Free",
      "defaultInUpdate": null
    }
  },
  "indexSettings": {
    "indexedInElastic": true,
    "indexedInDb": true
  },
  "enumSettings": {
    "hasEnumOptions": true,
    "enumOptions": ["Free", "Pro", "Enterprise"]
  },
  "relationSettings": {
    "hasRelation": false
  },
  "sessionSettings": {
    "isSessionData": false
  },
  "contextSettings": {
    "isContextData": false
  },
  "formulaSettings": {
    "isCalculated": false
  },
  "filterSettings": {
    "isFilterParameter": true,
    "filterName": "subscriptionLevel"
  },
  "staticJoin": {
    "isStaticJoin": false
  }
}
```

To apply this to your tenant data model, include it in your authentication settings:

```js
authentication.tenantProperties = [subscriptionLevelProperty];
```

### Tenant-Level Authorization Options

While multi-tenancy introduces data scoping by default, you can further control access based on **tenant-specific permissions** using:

```js
authentication.accessControl.permissionTypes.specialTenantPermissionsIsActive = true;
```

ðŸ”¹ These settings do not affect user roles or per-user permissions.
ðŸ”¹ Instead, they allow SaaS administrators to grant special permissions to specific tenants â€” such as feature toggles or subscription-level capabilities
